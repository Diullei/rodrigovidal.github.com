{"id":"26","title":"Programação Funcional - Currying e Aplicação Parcial de Funções","by":"Rodrigo Vidal","tags":["Programação Funcional, F#"],"category":"Programação Funcional, F#","date":"'2012-06-12'","deploy":"true","content":"\nOlá pessoal,\n\nNa ultima semana palestrei no DNAD12 onde falei sobre diversos conceitos de programação funcional. Com isso, muitas pessoas vieram falar comigo sobre o assunto, interessados em entender mais. Então, pretendo nas próximas semanas destrinchar grande parte dos assuntos que tratei na minha palestra. Escolhi este primeiro depois do @raphaelmolesim e posteriormente o @giovannibassi me perguntarem especificamente sobre ele. Para tentar sanar de uma vez por todas o entendimento sobre aplicação parcial e currying escrevo este post para todos  .\n\nDe uma maneira simples programação funcional é sobre aplicação de funções. Haskell Curry é o matemático cujo nome originou a expressão Currying, assim como a linguagem funcional Haskell. Currying permite ver todas as funções como membro de uma classe de funções que recebe apenas um parâmetro independente do número de argumentos necessário para realizar a computação em questão. Esta técnica permite então aplicação parcial de funções, como veremos neste post.\n\n##Currying\n\nCurrying é uma técnica de transformação, que inicia com uma função que recebe múltiplos parâmetros e a converte em uma sequencia de funções, em que cada uma dessas funções aceita apenas um parâmetro por vez e retorna a próxima função da sequência.\n\nIMAGEM\n\nPara entender programação funcional é extremamente importante que você entenda essa notação de flechas.\n\nTemos no primeiro caso, uma função que recebe dois parâmetros a e b, e retorna uma valor c. Repare que não estamos nos importando com tipos aqui, e adianto que currying se aplica para funções que recebem parâmetros de qualquer tipo. Então, esta função que inicialmente recebe dois parâmetros após sofrer a transformação Curry retorna uma nova função que recebe um parâmetro, e retorna uma nova função que recebe um parâmetro e retorna o valor final. Como assim?! Não entendi essa parte. Ainda não vi a diferença da primeira função para a segunda. Vamos lá!\n\nVamos imaginar uma função que calcula a adição entre dois inteiros.\n\nEm C# poderíamos escrever da seguinte forma:\n\n<pre><code>\nint Add(int x, int y)\n{\n     return x + y;\n}\n</code></pre>\n\nNo entanto também podemos escrever este método como uma função da seguinte forma:\n\n <pre><code>\nFunc<int,int, int> add = (x, y) => x + y\n</code></pre>\n\nQue é representada em notação de flechas como:\n\n**(int, int) > int**\n\nEsta função pode ser aplicada fazendo\n\n <pre><code>\nvar result = add(2,3);\n</code></pre>\n\nO resultado é 5. Como sabemos no C#, para aplicar essa função temos de passar os dois argumentos, não podemos passar apenas um deles. Currying trata justamente disso.\n\nA versão Curried correspondente a função add poderia se escrito da seguinte forma:\n\n <pre><code>\nFunc<int, Func<int, int>> add = x => y => x + y\n</code></pre>\n\nQue é representada em notação de flechas como:\n\n**int > int > int**\n\nPara facilitar o entendimento, é importante dizer que em notação de flechas a notação é associativa à direita, que significa, que a notação anterior pode ser escrita como:\n\n**int > (int > int)**\n\nOu seja.. uma função que recebe um inteiro, e retorna uma função que recebe um inteiro e retorna um inteiro.\n\nLegal, será que nós conseguiríamos criar uma função que transformasse então no C# uma função que recebe dois parâmetros em uma versão Curried? Veja:\n\n<pre><code>\npublic static Func<T1, Func<T2, TR>> Curry<T1, T2, TR>(this Func<T1, T2, TR> func)\n{\n    return par1 => par2 => func(par1, par2);\n}\n</code></pre>\n\nEssa seria uma maneira de definir um método genérico Curry que funciona para funções que recebem dois parâmetros.\n\nAssim poderíamos fazer algo como:\n\n<pre><code>\nstatic int Add(int a, int b)\n{\n    return a + b;\n}\n \nstatic void Main(string[] args)\n{\n    Func<int,int,int> add = Add;\n    Func<int,Func<int,int>> curriedAdd = add.Curry();\n}\n</code></pre>\n\nO que confunde, as vezes, os programadores é que em linguagens funcionais como Haskell e F# as funções são Curried por padrão. Ou seja, você não precisa fazer essa transformação, pois ela já é o padrão de aplicação de funções. Logo quando você define em F# ou Haskell (a sintaxe é a mesma):\n\n <pre><code>\nlet add x y = x + y\n</code></pre>\n\nque equivale a\n\n <pre><code>\nlet add = fun x &minus;> fun y &minus;> x + y\n</code></pre>\n\nou em Haskell\n\n <pre><code>\nlet add = \\x &minus;> \\y &minus;> x + y\n</code></pre>\n\nVocê está definindo uma função do tipo\n\n**int > int > int**\n\nOs tipos são inferidos automaticamente, dispensando a sintaxe verbosa que o C# necessita, por não ser uma linguagem primariamente funcional.\n\n##Aplicação Parcial de Funções\n\nAplicação parcial envolve passar menos argumentos para uma função que recebe múltiplos argumentos. Esse processo cria uma nova função que recebe menos argumentos.\n\nIMAGEM\n\nObs.: Currying é um processo que habilita a usarmos aplicação parcial de funções. Na sessão anterior obtemos uma função em sua forma curried, agora iremos utilizá&minus;la de forma parcial.\n\nDe maneira simples podemos aplicar parcialmente a função add definida na sessão anterior para criar uma nova função:\n\n**C#**\n\n<pre><code>\nstatic void Main(string[] args)\n{\n    Func<int,int,int> add = Add;\n    Func<int,Func<int,int>> curriedAdd = add.Curry();\n    Func<int, int> add5 = curriedAdd(5);\n    int result = add5(6);\n}\n</code></pre>\n\n**F#**\n\n<pre><code>\nlet add x y = x + y\n \nlet add5 = add 5\n \nlet result = (add 5) 6\n</code></pre>\n\nCriei uma nova função add5 a partir da função add passando como parâmetro da minha função o valor 5. Simples não?\n\nA aplicação de funções em F# ou Haskell é associativa a esquerda. Coloquei os parênteses, para facilitar o entendimento do que isso significa. Primeiro a função add é aplicada com apenas um parâmetro 5, essa aplicação retorna uma nova função, e então essa nova função é aplicada com o valor 6.\n\nRepare, no exemplo em C# transformamos uma função Uncurried, em uma função Curried via função Curry. Com isso fomos capazes de aplicar a função parcialmente, passando apenas um dos parâmetros necessários. No exemplo em F# não é necessário fazer Curry, pois a função já está na forma Curried por padrão, logo conseguimos aplicá&minus;la parcialmente com grande facilidade.\n\nOutro exemplo:\n\n**F#**\n\n<pre><code>\nlet result = [1..100]\n                 |> List.map (fun x &minus;> x * 2)\n                 |> List.filter (fun x &minus;> x < 50)\n                 |> List.sum\n</code></pre>\n\nNote que estamos aplicando as funções map e filter parcialmente. Isso acontece pois a função map assim como a filter recebem dois parâmetros, uma função (no caso do map uma projeção e no caso do filter um predicado) e uma lista como parâmetro. Em ambos os casos como resultado temos uma função do tipo:\n\n**int list &minus;> int list**\n\nOu seja, que recebe uma lista e retorna uma lista. Como já vimos em posts anteriores, o operador pipe&minus;forward pode ser definido como:\n\n<pre><code>\nlet (|>) x f = f x\n</code></pre>\n\nAssim ele aplica a função f que é nossa função parcial sobre o valor x que neste caso é nossa lista.\n\n**C#**\n\nEm C# é necessário fazer algumas modificações. Por exemplo não é possivel fazer curry do Select e do Filter diretamente pois eles são métodos de extensão. Ou seja operam sobre objetos. No entanto escrevi uma versão do select em uma classe estatica, para que possamos exemplificar, a pedido do Gustavo que comentou este post.\n\n<pre><code>\npublic static class IEnumerableEx\n{\n    public static IEnumerable<R> Select<T, R>(IEnumerable<T> source, Func<T, R> f)\n    {\n        foreach (var item in source)\n            yield return f(item);\n    }\n}\nstatic void Main(string[] args)\n{\n    var lista = Enumerable.Range(1, 100);\n    //Versão normal do select\n    Func<IEnumerable<int>, Func<int,int>, IEnumerable<int>> select = IEnumerableEx.Select;\n    //Versão curried\n    Func<IEnumerable<int>, Func<Func<int, int>, IEnumerable<int>>> selectCurried = select.Curry();\n    //Aplicação parcial &minus; passando apenas 1 parametro ao invés de 2\n    var listaSelecionada = selectCurried(lista);\n    //Aplicação parcial &minus; passando o segundo parametro que faltava\n    var listaDobrada = listaSelecionada(x => x * 2);\n    var listaTriplicada = listaSelecionada(x => x * 3);\n    var listaAoQuadrado = listaSelecionada(x => x * x);\n}\n</code></pre>\n\nÉ facil perceber que este tipo de abordagem é bem mais verbosa que em F#, basicamente pelo C# não inferir o tipo dessas funções.\n\nEste tipo de composição é largamente utilizada em programação funcional e nos permite reaproveitar e compor funções e outras estruturas de forma maestral. Bom pessoal espero que tenha ficado claro a separação dos dois conceitos, caso reste alguma dúvida por favor, não hesite em usar os comentários \n\nAbraço,\n\nRodrigo vidal\n","ref":"prog-func-currying-partial-app.post.mkdown"}