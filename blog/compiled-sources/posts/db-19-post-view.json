{"id":"19","title":"Estruturas de Dados Imutáveis - Listas","by":"Rodrigo Vidal","tags":["Programação Funcional, F#"],"category":"Programação Funcional, F#","date":"'2011-12-27'","deploy":"true","content":"\nFala pessoal\n\nDando continuidade ao post anterior, vamos hoje falar sobre uma estrutura extremamente importante para linguagens funcionais: Listas, e o que elas apresentam de tão diferente e marcante das estruturas de lista que conhecemos.\n\nSe você está chegando agora confira também o post anterior onde falei sobre Tuplas aqui.\n\n##O Tipo Lista\n\nEnquanto tuplas agrupam valores em uma unica entidade, listas permitem que você ligue os dados de maneira a formar uma corrente. Uma lista pode ser vazia ou composta por um elemento e uma outra lista. Um nome especial para representar essa lista vazia pode ser nil e para cada elemento cons cell de constructed list cell. Na imagem abaixo vemos a representação gráfica de uma lista.\n\nCada cons cell contém um único valor e uma referência para o próximo elemento da lista que pode ser uma nova cons cell ou uma lista vazia.\n\nVamos ver alguns exemplos de construção de listas:\n<pre><code>\nlet listaVazia = [] \n//val listaVazia : 'a list\n \nlet vogais = [\"a\";\"e\";\"i\";\"o\";\"u\"] \n//val vogais : string list = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n \nlet numeros = [1;2;3;4;5;6] \n//val numeros : int list = [1; 2; 3; 4; 5; 6]]\n</code></pre>\n\nO código acima é bem simples e acredito que não requeira explicação. Um ponto importante a notar é o mecanismo de inferência de tipo atuando novamente. No primeiro exemplo é construida uma lista vazia, e seu tipo é uma lista genérica. No segundo exemplo é construida uma lista de strings, e no terceiro uma lista de inteiros. É importante notar que todos os elementos de uma lista devem possuir o mesmo tipo, diferentemente das tuplas que vimos anteriormente que podem agregar diferentes tipos.\n\n##Operadores de Listas\n\nEm F# são definidos alguns operadores básicos para tratarmos com listas. As listas do F# estão definidas no modulo FSharp.List . Vamos ver algumas facilidades agora.\n\n###List Ranges\n\nNos permite criar listas de maneira facilitada e de maneira menos verbosa.\n\n<pre><code>\nlet range = [1..10] \n//val range : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\nlet charRange = ['a'..'f'] \n//val charRange : char list = ['a'; 'b'; 'c'; 'd'; 'e'; 'f']\nList Comprehensions\n\nlet prepost x = [ yield x&minus;1; yield x; yield x+1] \nlet result = prepost 10 \n//val prepost : int &minus;> int list \n//val result : int list = [9; 10; 11]\n</code></pre>\n\nNo exemplo acima criamos uma função chamada prepost que recebe um valor x e a partir disso cria uma lista com três valores, o antecessor, o proprio, e seu sucessor. Perceba que utilizamos a palavara chave yield, que em F# é o equivalente como você ja deve ter imaginando do nosso querido yield return.\n\n<pre><code>\nlet multiplesOf3 x = [for i in 1..10 &minus;> x * i] \nlet result = multiplesOf3 5 \n//val multiplesOf3 : int &minus;> int list\n//val result : int list = [5; 10; 15; 20; 25; 30; 35; 40; 45; 50]\n</code></pre>\n\nJá neste exemplo criamos uma função que gera dez multiplos do valor passado como parametro, e utilizamos a expressão for .. in .. > . É válido dizer que isso nos permite criar lógicas interessantes para construção de listas.\n\n###O Operador Cons e Append\n\nO operador cons é represtando por :: na verdade é uma simplificação da função List.Cons, que coloca cada novo elemento como a nova cabeça da lista. O operador cons é associativo a direita, o que significa que ele compõe valores da direita para a esquerda.\n\n<pre><code>\nlet numeros2 = 1 :: 2 :: 3 :: 4 :: 5 :: 6 :: [] \n//val numeros2 : int list = [1; 2; 3; 4; 5; 6]\n \nlet impares = [1;3;5;7;9] \nlet pares = [0;2;4;6;8]\nlet todos = pares @ impares \n//val todos : int list = [0; 2; 4; 6; 8; 1; 3; 5; 7; 9]\n</code></pre>\nO operador append, representado por @  é uma simplificação para a função List.append que transforma duas listas em uma.\n\n###Algumas Funções do Módulo List\n\nDuas funções importantissimas são a função List.head que retorna a cabeça da lista..\n\n<pre><code>\nlet head = List.head [1..10] \n//val head : int = 1\n</code></pre>\n.. e a função List.tail que retorna a cauda da lista, ou seja, todos os elementos a partir da cabeça.\n\n<pre><code>\nlet tail = List.tail [1..10] \n//val tail : int list = [2; 3; 4; 5; 6; 7; 8; 9; 10]\n</code></pre>\nEstas funções são essenciais quando estamos lidando com recursão e por isso resolvi apresentá&minus;las aqui. Ja falamos bastante sobre como trabalhar com listas com F#, no entanto, o mais interessante ainda estar por vir. Você como um leitor atento deve ter reparado que estas listas não são as mesmas listas que acompanham o .NET Framework, ou as listas, que você está acostumado a utilizar com C# no namespace System.Collections.Generic, e o tipo List<>.\n\nMas então o que essas listas tem de diferente?\n\n###Listas Imutáveis\n\nUma lista ser imutável significa que nós podemos construir uma lista, nós não podemos pegar uma lista existente e modificá&minus;la; nós não podemos adicionar ou remover um elemento. Funções que precisam adicionar novos elementos ou removê&minus;los sempre retornarão uma nova lista sem modificar a original, porque modificar uma lista é simplesmente impossivel. Isso está de acordo com o conceito de nós eliminarmos efeitos colaterais e indesejados em funções que manipulam listas.\n\nSeguindo o post sobre tuplas vou mostrar como seria de maneira simples uma Lista imutável em C#\n<pre><code>\npublic class FuncList<t>\n{\n    public bool IsEmpty { get; private set; }\n    public T Head { get; private set; }\n    public FuncList<t> Tail { get; private set; }\n \n    public FuncList()\n    {\n        IsEmpty = true;\n    }\n \n    public FuncList(T head, FuncList<t> tail)\n    {\n        IsEmpty = false;\n        Head = head;\n        Tail = tail;\n    }\n}\n \npublic static class FuncList\n{\n    public static FuncList<t> Empty<t>()\n    {\n        return new FuncList<t>();\n    }\n \n    public static FuncList<t> Cons<t>(T head, FuncList<t> tail)\n    {\n        return new FuncList<t>(head, tail);\n    }\n}\n</code></pre>\nA classe FuncList<T> é generica, então ela pode armazenar valores de qualquer tipo. Ela possui uma propriedade IsEmpty que é True quando nós criamos uma lista vazia pelo construtor sem parâmetro. O segundo construtor recebe dois argumentos, o primeiro é a cabeça da lista e o segundo é a lista que segue como cauda para o novo valor. \nOu seja o primeiro construtor equivale a lista vazia do F# [] e o segundo ao operador Cons ::  do F#.\n\nAgora como criar uma lista a partir desse novo tipo? Vemos abaixo:\n\n<pre><code>\nvar numbers = FuncList.Cons(1, FuncList.Cons(2, FuncList.Cons(3, FuncList.Empty<int>())));\n//Equivalente em F#\n//let numbers = 1 :: 2 :: 3 :: []\n</code></pre>\nAgora vamos criar um método que calcule a soma de todos os elementos de uma lista formada de inteiros\n\n<pre><code>\npublic static int SumList(FuncList<int> numbers)\n{\n    return numbers.IsEmpty ? 0 : numbers.Head + SumList(numbers.Tail);\n}\nint sum = FuncList.SumList(numbers);\n</code></pre>\n\nA função acima faz uso de recursão todos os elementos da lista. Caso a lista esteja vazia, retorna o valor zero, caso contrário retorna a cabeça + o resultado da função novamente sobre a cauda da lista, sucessivamente até encontrar como cauda apenas a lista vazia.\n\nBom pessoal, por hoje era isso!\n","ref":"estruturas-dados-imutaveis-listas.post.mkdown"}