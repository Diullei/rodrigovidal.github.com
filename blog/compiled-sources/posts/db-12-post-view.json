{"id":"12","title":"F# 3.0 - O que vem por ai..","by":"Rodrigo Vidal","tags":["F# 3"],"category":"F#","date":"'2011-10-19'","deploy":"true","content":"\nOlá pessoal,\n\nDemorei um pouco a dar esta notícia aqui no blog mas para quem não sabe foi a anunciado no Build, evento realizado pela Microsoft Corp, uma versão Developer Preview do F# 3.0 embarcado no Visual Studio 11.\n\nLinguagens de programação, tem objetivos diferentes, nichos diferentes, resolvem problemas de maneiras diferentes, senão fosse assim poderiamos ter apenas uma correto? Estou muito feliz com o investimento e a atenção que a linguagem F# está recebendo da Microsoft. Primeiro porque se você é um desenvolvedor C#/VB tradicional ela te eleva a um novo patamar, segundo porque vem oferecendo features ainda inexistentes na plataforma .NET e/ou fora dele. F# está influenciando linguagens como o C# por exemplo que irá receber na versão 5 a tão falada feature para processamento Assincrono, ja presente no F# na versão 2.0.\n\nDonald Syme, criador do F#, deixou uma mensagem bem clara em sua palestra no Build. F# não tem como objetivo, tomar o lugar do C# ou do VB como uma linguagem de proposito geral. Segundo ele proprio, C# e VB hoje ja realizam muito bem esse papel. F# quer atender áreas computacionais e mercados onde as outras não são eficientes.\n\nEsta versão liberada em Preview apresenta duas principais features e uma feature bonus : são os Type Providers e as Query Expressions.\n\n##Type Providers\n\nOs Type Providers vem pra resolver o problema de aplicações complex data-centric. Ele fornece em tempo de compilação acesso a objetos tipados, oriundas de diversas fontes, através de providers. O namespace destes providers é Microsoft.FSharp.Data.TypeProviders, é preciso adicionar a referência para a dll FSharp.Data.TypeProviders.dll para que se tenha acesso a esse namespace.\n\nEsta versão já veio com alguns Type Providers embutidos como para OData, WSDL e SQL (por L2SQL ou Entitiy Framework)\n\nAbaixo segue um exemplo que eu fiz acessando uma fonte em OData da NetFlix. O grande diferencional nesse código é que após voce ter criado o tipo NetFlix, em tempo de compilação, você terá acesso a todas a propriedades do catalogo, com Intellisense e tipos.\n\n![Valid XHTML](/blog/img/typeprovider_thumb.jpg)\n\n##Query Expressions\n\nVimos o poder que Type Providers oferecem para manipular grande esquemas e quantidades de dados. No entanto precisamos de suporte da linguagem para trabalhar em cima desses dados, com joins, filtros e condições. Para isso foram criadas as Query Expressions. Nada mais é do que uma computation expression criada para fornecer esses recursos e trazer uma linguagem mais proxima de queries à linguagem F#. Lembra bastante a Query Syntax presente no C#.\n\nVejam o exemplo acima agora usando uma Query Expression:\n\n![Valid XHTML](/blog/img/queryexp_thumb.jpg)\n\nComo podem ver o highlight do VS11 ainda não está contemplando as novas keywords até porque há chances de algumas delas mudarem de nome ou serem aprimoradas. Mas basicamente esta é a idéia, integrar queries à linguagem na mesma abordagem LINQ. Legal né?\n\n##Auto-Implemented Properties\n\nSintaxe segundo o MSDN\n\n// Automatically implemented properties. \n[attributes ] \n[ static ] member val [accessibility-modifier ] PropertyName = initialization-expression [ with get, set ]\n\nEssa é a forma de se definir uma propriedade auto-implementada. Como sabemos F# é uma linguagem multi-paradigma, e entre eles está o paradigma OO. No entanto, esta funcionalidade tem umas peculiridades que serão analisadas melhor em futuros posts.\n\n![Valid XHTML](/blog/img/autoprop_thumb.jpg)\n\nPor hoje era isso pessoal..\n\nAbraço, \nRodrigo Vidal\n","ref":"fsharp-3.post.mkdown"}