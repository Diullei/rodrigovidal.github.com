{"id":"7","title":"F# - Imutabilidade","by":"Rodrigo Vidal","tags":["Programação Funcional, F#"],"category":"Programação Funcional, F#","date":"'2011-04-10'","deploy":"true","content":"\nPode-se notar que, eu de maneira suspeita não utilizei a palavra variável nos demais artigos sobre F#, mas sim a palavra value. A razão para isso é que em programação funcional, a estruturas que você declara são imutáveis por padrão, ou seja, não podem ser mudadas.\n\nSe uma função em algum momento muda o estado do programa, como escrever em um arquivo ou mudar o valor de uma variavel global em memória, então é conhecido como side effect ou efeito colateral. Por exemplo, invocando a função printfn, ela retorna unit, mas tem o efeito colateral de escrever um texto na tela. De maneira similar, se uma função altera o valor de alguma coisa em memoria, este também é um efeito colateral.\n\nEfeito colaterais não são de todo ruins, mas efeitos colaterais não intencionais são a raiz de muitos bugs. Até mesmo o mais bem intencionado dos programadores cometem erros se eles não estiverem cientes dos efeitos de uma função. Valores imutáveis ajudam a escrever código seguro porque você não pode estragar aquilo que não pode mudar.\n\nVamos entender o código abaixo que demonstra um exemplo de imutabilidade escrito em C#.\n\n<pre><code>\npublic class Color\n    {\n        private readonly int red;\n        private readonly int green;\n        private readonly int blue;\n\n        public Color(int red, int green, int blue)\n        {\n            this.red = red;\n            this.green = green;\n            this.blue = blue;\n        }\n\n        public Color MixColor(Color color)\n        {\n            var newRed = CalculateComponent(this.red, color.red);\n            var newGreen = CalculateComponent(this.red, color.green);\n            var newBlue = CalculateComponent(this.red, color.blue);\n\n            return new Color(newRed, newGreen, newBlue);\n        }\n\n        private int CalculateComponent(int oldColor, int newColor)\n        {\n            return (oldColor + newColor)/2;\n        }\n    }\n</code></pre>\n\nNo código acima, podemos perceber que existe um construtor para o objeto Cor que recebe três parametros seguindo o padrão RGB. Seus atributos são readonly, e atribuidos somente durante a contrução do objeto. Existe também um método chamado MixColor que permite que uma Cor seje misturada à outra. Em um cenário imperativo, nós atualizariamos as propriedades do nosso objeto, no entanto isso não é possivel, pois nosso objeto é imutável. Ao invés disso, estamos criando um nova Cor, que representa uma instância da cor modificada e a retornando como resultado.  Desta forma nosso objeto é imutável, mais facil de testar e menos sujeito a efeitos colaterais.\n\nVamos para outro exemplo de Imutabilidade e Mutabilidade.\n\nDado o código abaixo.\n\n<pre><code>\nstatic void Main(string[] args)\n        {\n            Console.WriteLine(\"--System.String é imutável\");\n            string linguagem = \"F#\";\n            string outraLinguagem = linguagem;\n            outraLinguagem = \"Boo\";\n            Console.WriteLine(linguagem);\n            Console.WriteLine(outraLinguagem);\n\n            Console.WriteLine(\"--StringBuilder é mutável\");\n            StringBuilder nome = new StringBuilder(\"Rodrigo Vidal\");\n            StringBuilder outroNome = nome;\n            outroNome.Append(\" - Don Syme\");\n            Console.WriteLine(nome.ToString());\n            Console.WriteLine(outroNome.ToString());\n\n            string teste1 = \"Rodrigo\";\n            string teste2 = \"Rodrigo\";\n            ToUpper(teste1);\n            Console.WriteLine(teste1);\n            Console.WriteLine(teste2);\n            Console.ReadKey();\n        }\n</code></pre>\n\nPodemos notar que no codigo acima, ao modificarmos a variável outraLinguagem com o valor Boo, a variavel linguagem não foi alterada. A razão para isso é que o Tipo System.String é imutável, ou seja, toda vez que uma string é modificada, na realidade é criada uma nova string.\n\nUma vez entendido este conceito vamos para o F#. Como foi dito, anteriormente, por default tudo em F# é imutável.\n\nVamos aos exemplos.\n\n<pre><code>\nlet nome = \"Rodrigo Vidal\"\nlet nome = \"Don Syme\"\n</code></pre>\n\nExibirá como erro ao rodar no F# Interactive: error FS0037: Duplicate definition of value 'nome'\nAté ai tudo bem.. não podemos ter duas definições de value com o mesmo nome. Próximo:\n\n<pre><code>\nlet nome = \"Rodrigo Vidal\"\nnome = \"Don Syme\"\n</code></pre>\n\nEste trecho terá erro em tempo de compilação, agora ele é irrelevante, mas ele fará você tentar usar o codigo abaixo para resolver o problema.\n\n<pre><code>\nlet nome = \"Rodrigo Vidal\"\nnome <- \"Don Syme\"\n</code></pre>\n\nVocê pode imaginar que esta é a forma de se tentar burlar a imutabilidade, mas não é. Este codigo exibirá a mensagem error FS0027: This value is not mutable. Ou seja, o Value nome não é mutável, e esta operação não é permitida.\n\nBom para ressaltar a imutabilidade por default no F# é aplicado não só a Values mas também a todos os tipos de estrutura. Trabalhar com valores difere bastante de trabalhar com variáveis, então usar o termo Value ao invés de Variável, não é apenas uma questão de terminologia, mas sim de conceito. Por isso usarei essa terminologia durante os próximos posts. Usar valores imutáveis requer que nós expressemos muitos problemas de maneiras diferentes das que estamos acostumados. Nos próximos posts, poder ver na prática como isso se torna importante, para refatorações, testes unitários, lazy evaluation, e paralelismo, entre outros assuntos.,\n\nAbraço,\nRodrigo Vidal\n","ref":"fsharp-imutabilidade.post.mkdown"}