{"id":"23","title":"Programação Funcional - Pattern Matching","by":"Rodrigo Vidal","tags":["JavaScript"],"category":"JavaScript","date":"'2012-02-15'","deploy":"true","content":"\nOlá pessoal! Vamos hoje falar sobre pattern matching que é um recurso extremamente utilizado em programação funcional. Veremos alguns exemplos escritos em F#. Este post surgiu devido a uma conversa com o amigo Bernardo Rosmaninho que demonstrou interesse no assunto, e como prometido, aqui está o post \n\nSegundo a Wikipédia\n\n> In computer science, pattern matching is the act of checking some sequence of tokens for the presence of the \n> constituents of some pattern. In contrast to pattern recognition, the match usually has to be exact. The patterns \n> generally have the form of either sequences or tree structures. Uses of pattern matching include outputting the \n> locations (if any) of a pattern within a token sequence, to output some component of the matched pattern, and to \n> substitute the matching pattern with some other token sequence (i.e., search and replace).\n\nDado isso, eu diria que pattern matching é uma série de regras que serão executadas se o padrão informado encaixar com a entrada, permitindo também sua decomposição. Esta expressão então retorna o resultado da regra acionada. Como consequência, todas as regras de um pattern match devem retornar o mesmo tipo.\n\nPattern matching é de alguma maneira similar ao switch do C# e do C++, mas muito mais poderoso, como veremos agora.\n\n##Você está com sorte!\n\n<pre><code>\nlet lucky = function\n    | 7 &minus;> \"Você está com sorte!\"\n    | _ &minus;> \"Desculpe mas você está sem sorte!\"\n</code></pre>\n\nComo vemos este código está escrito em F# e define uma simples função, chamada \"lucky\". Está função possui duas regras, mas primeiro analizemos o tipo desta função. Executando o código acima no F# Interactive (fsi.exe) obtemos que esta função é do tipo (lucky : int &minus;> string). Ou seja, ela recebe um valor do tipo int e retorna uma string. Note que não foi necessário definir um parâmetro para a função, e mesmo assim ela parece receber um. Este é um comportamento da keyword function utilizada, que faz com que o ultimo parâmetro seja o valor a ser comparado com a regra.\n\nBom então como dito anteriormente esta função possui duas regras. A primeira determina que caso o valor recebido como parâmetro do tipo inteiro seja o numero 7, então esta função retornara a string \"Você está com sorte!\". A segunda regra utiliza de um \"underscore\" para dizer que, qualquer outro valor que não satisfaça a regra anterior deve retornar \"Desculpe mas você está sem sorte!\". Cada regra se inicia com o pipe a esquerda. É importante notar que em F# a identação do código delimita o escopo, e o pipe deve estar identado corretamente para que seu código compile. Perceba também que, a regra é separada de seu resultado pelo operador \"&minus;>\".\n\nEstá função é bem simples e não apresenta nenhuma regra complexa, preparei mais algumas funções para nos familiarizarmos mais com o conceito de pattern matching. Veja se é capaz de entender o que a função abaixo faz:\n\n<pre><code>\nlet sayMe = function\n    | 1 &minus;> \"One\"\n    | 2 &minus;> \"Two\"\n    | 3 &minus;> \"Three\"\n    | 4 &minus;> \"Four\"\n    | 5 &minus;> \"Five\"\n    | 6 &minus;> \"Six\"\n    | 7 &minus;> \"Seven\"\n    | _ &minus;> \"Not between 1 and 7\"\n</code></pre>\n\nMuito simples não é mesmo?\n\n##Pattern Matching em uma Função Recursiva\n\nUma implementação simples de uma função recursiva usando pattern matching é o didático fatorial. (Eu ainda não tratei de função recursivas aqui no blog, mas o post está a caminho).\n\nNote:\n<pre><code>\nlet rec factorial = function\n    | 0 &minus;> 1\n    | n &minus;> n * factorial (n&minus;1)\n</code></pre>\nEm F# para determinar que uma função é recursiva é necessário utilizar a keyword \"rec\" explicitamente! Executando esta função no FSI, obtemos o tipo (factorial : int &minus;> int). Ou seja recebe um inteiro e retorna um inteiro.\n\nA primeira regra determina que se o valor do parâmetro for 0 então será retornado o valor 1, caso esta regra não se aplique, e for passado um valor diferente de zerão então o parâmetro é multiplicado por uma nova chamada a função utilizando deste valor menos um. Lindo não?\n\n##Desconstruindo Valores em Pattern Matching\n\nVamos supor que desejamos somar dois pontos. Segue\n <pre><code>\nlet addVectors v1 v2 =\n    (fst v1 + fst v2, snd v1 + snd v2)\n</code></pre>\nO código acima apresenta uma solução, que não utiliza de pattern matching. Pela utilização das funções fst e snd, que trabalham com tuplas com compilador do F# consegue inferir que os valores v1 e v2 são tuplas e soma os primeiros valores de cada ponto, e depois o segundo valor, e adicionalmente neste processo cria uma nova tupla como resultado.\n\nNo entanto poderíamos utilizar pattern matching em um processo de desconstrução para obtermos estes valores. Vejamos\n\n <pre><code>\nlet addVectors v1 v2 =\n    match v1, v2 with\n    | (x1, y1), (x2, y2) &minus;> (x1 + x2, y1 + y2)\n</code></pre>\nNesta função utilizamos uma nova expression \"match .. with\" que é necessária quando a função precisa de mais de dois parâmetros.  Nesta função é necessário notar algumas coisas importantes.\n\nEla tem o tipo int * int &minus;> int * int &minus;> int * int , ou seja, recebe duas tuplas de inteiro e retorna uma tupla de inteiro\nConstruímos uma tupla com os valores v1 e v2 em match v1, v2 with, para utilizarmos ambos os valores na regra\nRealizamos o processo de desconstrução da tupla na regra obtendo diretamente o valores de x1, x2, y1, y2 não sendo necessário o uso das funções.\nDada a desconstrução criamos uma nova tupla com os resultados somados.\nO mecanismo de desconstrução torna pattern matching extremamente poderoso e permite uma melhor leitura da regra a ser aplicada, tornando seu código ainda mais legível. É também extremamente sucinta.\n\n##Pattern Matching em Funções para Tuplas\n\nAcima nós utilizamos as funções fst e snd para obter o primeiro e o segundo valor para tuplas. No entanto vamos olhar como estas funções podem ser implementadas?\n\n<pre><code>\nlet first = function\n    | (x, _, _) &minus;> x\nlet second = function\n    | (_, x, _) &minus;> x\nlet third = function\n    | (_, _, x) &minus;> x\n</code></pre>\n\nAs três funções acima trabalham com desconstrução de tuplas de 3 elementos. Dada uma tupla de 3 elementos esta é desconstruída, e o primeiro elemento é marcado para o valor de x, feito isso a função retorna o valor de x. Feito isso podemos obter o valor de qualquer dos 3 membro de uma tupla de 3 elementos.\n\n##O operador lógico AND\n\nBom vamos construir uma função que funciona como o operador AND (&&)\n<pre><code>\nlet and x y =\n    match x,y with\n    | true, true &minus;> true\n    | true, false &minus;> false\n    | false, true &minus;> false\n    | false, false &minus;> false\n</code></pre>\nDevido ao mecanismo de inferência a função and recebe dois valores do tipo Booleana e retorna um novo valor.\n\nO compilador do F# é muito poderoso como já percebemos.. Como exercício tente retirar a terceira regra e compilar o código. Você perceberá que o compilador do F# emitirá um warning avisando que uma possível regra não está sendo validada, mas irá compilar. Caso a execução caia em uma regra inexistente uma exceção do tipo MatchFailureException será lançada.\n\n##Agrupando Padrões\n\nVamos descrever uma função que teste se um determinado caractér é uma vogal.\n\n<pre><code>\nlet isVowel c =\n    match c with\n    | 'a' | 'e' | 'i' | 'o' | 'u' &minus;> true\n    | _ &minus;> false\n</code></pre>\nPerceba que neste caso estamos agrupando padrões, não havendo necessidade de criarmos uma regra para cada uma das vogais, visto que elas compartilham da mesma regra.\n\n##Guardas, Guardas!\n\nVocê já deve ter percebido como Pattern Matching é útil e permite as mais diversas construções. No entanto existem outros casos que podem ser necessários e para isso temos o que chamamos de Guards que é utilizado quando precisamos de alguma logica para saber se uma regra vai combinar.\n\nNo exemplo abaixo faremos uso de diversas construções de pattern matching. Veja:\n\n<pre><code>\nlet bmiIndex weight height =\n    let bmi = weight / height ** 2.0\n    let (skinny, normal, fat) = (18.5, 25.0, 30.0)\n    match bmi with\n    | _ when bmi <= skinny &minus;> \"You're underweight\"\n    | _ when bmi <= normal &minus;> \"You're normal\"\n    | _ when bmi <= fat &minus;> \"You're fat\"\n    | _ &minus;> \"You're a whale\"\n</code></pre>\n\nA função acima serve para calcular o índice de massa corpórea e informar se você está acima ou abaixo do peso. Fizemos uma função externa chamada bmiIndex que recebe os parâmetros peso e altura. Na primeira linha interna calculamos o que chamamos de bmi. Em seguida usamos pattern matching em tuplas para definir três valores. Após fazemos pattern matching no bmi e aplicamos a regra \"menor ou igual\". Para essa regra não ser repetida 3 vezes, eu a extraímos para a função chamada bmi, para melhorar a legibilidade. Para podemos aplicar essas regras utilizamos a keyword \"when\", que chamamos de when guards!\n\n##Desconstrução de Listas\n\nAssim como fizemos com tuplas é possível descontruir listas também.\n\n<pre><code>\nlet listStatus = function\n    | [] &minus;> \"the list is empty\"\n    | x::[] &minus;> \"The list has one element:\" + string x\n    | x::y::[] &minus;> \"The list has two elements \" + string x + \" and \" + string y\n    | x::y::_ &minus;> \"Too long\"\n</code></pre>\n\nA função acima dá o status de uma lista. Se ela está vazia, se possui um elemento, se possui dois elementos, ou se possuir mais elementos. Perceba que o operador :: realiza a desconstrução da lista em elementos. No caso x combina para o primeiro elemento e y para o segundo, caso possua. Caso não lembre, o operador :: é usado para construir listas como em\n\n <pre><code>\nlet list = 1::2::3::[]\n</code></pre>\n\nQue retornaria [1;2;3].\n\nConclusão &minus;> **Pattern Matching Everywhere**\n\nPattern matching como vimos é um mecanismo poderoso, e que nos permite diversas construções. Ele é simples e sucinto, o que facilita muito sua leitura. O que foi mostrado aqui não é tudo que é possível fazer com Pattern Matching. É também possível utilizar com estruturas de dados complexas criadas pelo desenvolvedor além de listas e tuplas. Em F# pattern matching é largamente utilizado até mesmo em estruturas que não parecem fazer uso desta técnica. Como no exemplo abaixo!\n <pre><code>\nlet xs = [(1,3), (2,4), (3,2), (6,2), (7,1)]\nxs |> List.map (fun (x,y) &minus;> x+y)\n</code></pre>\nPor hoje era isso!\n","ref":"prog-func-pattern-matching.post.mkdown"}