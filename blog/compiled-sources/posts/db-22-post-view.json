{"id":"22","title":"Javascript - É ou não igual?!","by":"Rodrigo Vidal","tags":["JavaScript"],"category":"JavaScript","date":"'2012-01-26'","deploy":"true","content":"\nOlá pessoal,\n\nContinuando a série, sobre JS, vamos falar um pouco sobre dois operadores extremamente simples. Eles são capazes de comparar dois valores e dizer se eles são iguais ou não. Realmente simples não? Provavelmente, você sabe muito bem, como isso funciona na sua linguagem server&minus;side, ao comparar dois valores, dois arrays, ou até mesmo dois objetos. No entanto, olhando o código que já tive a oportunidade de observar nas empresas, percebo que os desenvolvedores não entendem muito bem como isso se dá no JavaScript. Então vamos entender de uma vez por todas, se é ou não é igual.\n\nA primeira coisa a se saber é que Javascript possui dois operadores de igualdade! O que? Dois? É isso mesmo. Você provavelmente utiliza um deles com bastante frequência: O \"==\". Agora você pode pensar, nossa que obvio. Isso eu já sabia. Mas você realmente sabe como este operador funciona? Você conhece seu irmão menos brincalhão? O \"===\" ?\n\nNão. Eu não errei o operador acima, realmente são 3 (três) \"igual\" seguidos. O desconhecimento deste segundo operador é a origem de muitos bugs estarem estourando por ai, sem você realmente entender o porquê, e geralmente não tão simples de entender, principalmente, se seu código não está cobertos por testes. Espera! Testes no Javascript? (Mas isso é tema pra outro post).\n\nOs operadores == e === checam se dois valores são iguais mas com duas definições diferentes de igualdade. Ambos os operadores aceitam operandos de qualquer tipo, e ambos retornam true se os operando forem iguais e false se eles forem diferentes. O operador === é conhecido como operador de igualdade estrita, e checa quando os dois operandos são idênticos, usando uma definição mais estrita. O operador == é conhecido como operador de igualdade, ele checa quando os dois operador são iguais usando uma definição mais relaxada que permite conversões de tipo.\n\nJavascript suporta os operadores =, ==, ===. Podemos lê&minus;los da seguinte forma: \"é atribuído para\", \"é igual a\", \"é estritamente igual a\" respectivamente.\n\nOs operadores != e !== testam para o oposto exato dos operadores == e ===.\n\nObjetos no Javascript são comparados por referência e não por valor. Um objeto é igual a ele mesmo, mas diferente de qualquer outro objeto. Se dois objetos distintos tem o mesmo numero de propriedades, com os mesmo nomes e mesmo valores eles ainda assim não são iguais. Dois arrays com os mesmo elementos, na mesma ordem não são iguais uns aos outros.\n\n###Como funciona o ===\n\nO operador === avalia os operandos e então os compara, sem realizar conversão de tipo, dada a seguinte regra:\n\nSe os dois valores são de tipo diferentes, eles não são iguais.\nSe os dois valores são null ou ambos são undefined, eles são iguais.\nSe ambos os valores são o valor booleano true ou ambos são o valor booleano false, eles são iguais\nSe um ou mais valores são NaN, eles não são iguais. O valor NaN não é nunca igual a nenhum valor, incluindo ele mesmo.\nSe ambos os valores são números e tem o mesmo valor, eles são iguais; Se um valor é 0 e o outro &minus;0 eles também são iguais.\nSe ambos os valores são strings e contém exatamente os mesmos 16 bits, nas mesmas posições, então são iguais. Se as strings diferirem em tamanho ou posicionamento, não são iguais.\nSe ambos os valores referirem para o mesmo objeto, array, ou função, eles são iguais. Se referem para objetos diferentes não são iguais, mesmo que ambos tenham propriedades idênticas.\n\n###Como funciona o ==\n\nO operador == é menos estrito. Se os valores dos operandos não forem do mesmo tipo, ele tenta algumas conversões de tipo e realiza a comparação novamente.\n\nSe os valores tem o mesmo tipo, ele testa para igualdade estrita, como descrito acima, Se os valores forem estritamente iguais, eles são iguais.\nSe os dois valores não são do mesmo tipo, eles ainda podem ser considerados iguais:\n\nSe um dos valores é null e o outro é undefined, eles são iguais.\nSe um dos valores é um numero e o outro uma string, converte a string para um numero e tenta realizar a comparação novamente, usando o valor convertido.\nSe um é true, converte para 1 e tenta a comparação novamente, Se um é false, converte para 0 e tenta novamente.\nSe um valor é um objeto e o outro é um numero ou string converte o objeto para um primitivo e tenta novamente a comparação. Um objeto é convertido para um valor primitivo, usando o método toString() ou valueOf().\nQualquer outra combinação de valores não são iguais.\nUfa! Não tão simples não é mesmo?\n\nSegue alguns exemplos práticos que tenta permear algumas das regras acima\n\n<pre><code>\n// Operador === \n \n1 === \"1\"\n>> false\n \nnull === null\n>> true\n \nundefined === undefined\n>> true\n \ntrue === true\n>> true\n \nfalse === false\n>> true\n \nNaN === 1\n>> false\n \nNaN === NaN\n>> false\n \n2 === 2\n>> true\n \n0 === &minus;0\n>> true\n \n\"js\" === \" js\"\n>> false\n \n\"js\" === \"js\"\n>> true\n \nvar o1 = {}\n>> undefined\n \nvar o2 = {}\n>> undefined\n \no1 === o2\n>> false\n \nvar r1 = [1,2,3]\nvar r2 = [1,2,3]\n>> undefined\n \nr1 === r2\n>> false\n \nr1 === r1\n>> true\n \n//Operador ==\n \nnull == undefined\n>> true\n \n1 == \"1\"\n>> true\n \n1 == true\n>> true\n \n0 == false\n>> true\n \nvar o = {}\n>> o == \"teste\"\n</code></pre>\n\nPor hoje é só!\n\nAbraço! \n","ref":"javascript-e-ou-nao-igual.post.mkdown"}